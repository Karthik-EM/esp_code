#include <driver/i2s.h>
#include <arduinoFFT.h>

// I2S Microphone Pin Configuration
#define I2S_WS 15
#define I2S_SD 32
#define I2S_SCK 14
#define I2S_PORT I2S_NUM_0

// Audio Sample Configuration
#define I2S_SAMPLE_RATE 16000
#define SAMPLES_PER_CHUNK 256 // Each chunk is 16ms

// Onboard LED pin
#ifndef LED_BUILTIN
#define LED_BUILTIN 2
#endif

/// ===================================================================================
// ====== FINAL TUNING DIALS (OPTIMIZED WITH YOUR DATA) ======
// ===================================================================================

// --- SENSITIVITY ---
// These seem perfect, let's leave them.
#define SOFTWARE_GAIN_FACTOR 3.0 
#define TRIGGER_AMP_THRESHOLD 800
#define SUSTAIN_AMP_THRESHOLD 500

// --- SELECTIVITY (INTELLIGENCE) ---
// Tightening these based on your successful detection logs.
#define MIN_CONSECUTIVE_CHUNKS 10 // Was 5. Increased to reject voice.
#define MAX_EVENT_DURATION 200 
#define F_BINS_THRESHOLD_MIN 80   // Was 40. Increased to ensure a very strong broadband signal.
#define FFT_ENERGY_THRESHOLD 1000

// ==========================================
// ==========================================

// State Machine and data variables
enum State { IDLE, TRIGGERED };
State currentState = IDLE;
unsigned long eventStartTime = 0;
int consecutiveLoudChunks = 0;
int16_t peak_amplitude_of_event = 0;
ArduinoFFT<double> FFT = ArduinoFFT<double>();
double vReal[SAMPLES_PER_CHUNK];
double vImag[SAMPLES_PER_CHUNK];
int16_t peak_chunk_buffer[SAMPLES_PER_CHUNK];
unsigned long ledOnTime = 0;
const int ledOnDuration = 5000;

void setup() {
  Serial.begin(115200);
  Serial.println("Definitive Hybrid Detector Initializing...");
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, LOW);
  i2sInit();
  Serial.println("System Ready. Calibrating for range...");
  Serial.println("------------------------------------");
}

void loop() {
  int16_t samples[SAMPLES_PER_CHUNK];
  size_t bytes_read;
  i2s_read(I2S_PORT, (void*)samples, SAMPLES_PER_CHUNK * sizeof(int16_t), &bytes_read, portMAX_DELAY);

  if (bytes_read > 0) {
    int16_t current_peak_amplitude = 0;
    // Apply gain and find the peak amplitude for this chunk
    for (int i = 0; i < SAMPLES_PER_CHUNK; i++) {
      int32_t amplified_sample = (int32_t)samples[i] * SOFTWARE_GAIN_FACTOR;
      if (amplified_sample > 32767) amplified_sample = 32767;
      if (amplified_sample < -32768) amplified_sample = -32768;
      samples[i] = (int16_t)amplified_sample; // Overwrite original sample with amplified one

      if (abs(samples[i]) > current_peak_amplitude) {
        current_peak_amplitude = abs(samples[i]);
      }
    }

    // State machine for event detection
    switch (currentState) {
      case IDLE:
        if (current_peak_amplitude > TRIGGER_AMP_THRESHOLD) {
          currentState = TRIGGERED;
          eventStartTime = millis();
          consecutiveLoudChunks = 1;
          peak_amplitude_of_event = current_peak_amplitude;
          memcpy(peak_chunk_buffer, samples, sizeof(samples));
          Serial.printf("EVENT TRIGGERED! Peak Amp: %d\n", current_peak_amplitude);
        }
        break;

      case TRIGGERED:
        if (current_peak_amplitude > SUSTAIN_AMP_THRESHOLD) {
          consecutiveLoudChunks++;
          if (current_peak_amplitude > peak_amplitude_of_event) {
            peak_amplitude_of_event = current_peak_amplitude;
            memcpy(peak_chunk_buffer, samples, sizeof(samples));
          }
        }

        if (millis() - eventStartTime > MAX_EVENT_DURATION) {
          Serial.printf("EVENT ENDED. Duration: %d chunks. Peak Amp: %d.\n", consecutiveLoudChunks, peak_amplitude_of_event);
          
          if (consecutiveLoudChunks >= MIN_CONSECUTIVE_CHUNKS) {
            Serial.println("-> Duration OK. Analyzing content...");
            
            for (int i = 0; i < SAMPLES_PER_CHUNK; i++) {
              vReal[i] = (double)peak_chunk_buffer[i];
              vImag[i] = 0;
            }

            FFT.windowing(vReal, SAMPLES_PER_CHUNK, FFT_WIN_TYP_HAMMING, FFT_FORWARD);
            FFT.compute(vReal, vImag, SAMPLES_PER_CHUNK, FFT_FORWARD);
            FFT.complexToMagnitude(vReal, vImag, SAMPLES_PER_CHUNK);
            
            int significant_bins = 0;
            for (int i = 2; i < (SAMPLES_PER_CHUNK / 2); i++) {
              if (vReal[i] > FFT_ENERGY_THRESHOLD) {
                significant_bins++;
              }
            }
            Serial.printf("-> Forensic F-Bins: %d\n", significant_bins);

            if (significant_bins > F_BINS_THRESHOLD_MIN) {
              digitalWrite(LED_BUILTIN, HIGH); 
              ledOnTime = millis();
              Serial.println(">>> SIGNATURE MATCH: Sustained & Broadband. GUNSHOT. <<<");
              Serial.println("------------------------------------");
            } else {
              Serial.println("-> Content REJECTED (Not broadband).");
            }
          } else {
            Serial.println("-> Duration REJECTED (Too short).");
          }
          currentState = IDLE;
        }
        break;
    }
  }

  if (ledOnTime > 0 && millis() - ledOnTime > ledOnDuration) {
    digitalWrite(LED_BUILTIN, LOW);
    ledOnTime = 0;
  }
}

void i2sInit() {
  i2s_config_t i2s_config = {
    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
    .sample_rate = I2S_SAMPLE_RATE,
    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
    .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
    .communication_format = I2S_COMM_FORMAT_STAND_I2S,
    .intr_alloc_flags = 0,
    .dma_buf_count = 8,
    .dma_buf_len = SAMPLES_PER_CHUNK,
    .use_apll = false
  };
  i2s_driver_install(I2S_PORT, &i2s_config, 0, NULL);
  const i2s_pin_config_t pin_config = {
    .bck_io_num = I2S_SCK,
    .ws_io_num = I2S_WS,
    .data_out_num = -1,
    .data_in_num = I2S_SD
  };
  i2s_set_pin(I2S_PORT, &pin_config);
}
